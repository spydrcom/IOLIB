
package net.myorb.data.abstractions;

import net.myorb.data.abstractions.ServerConventions;
import net.myorb.data.abstractions.SimpleStreamIO.TextSource;

import net.myorb.data.notations.json.JsonSemantics;
import net.myorb.data.notations.json.JsonReader;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;

import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.SAXException;

import java.io.StringReader;
import java.io.Reader;

/**
 * establish conventions for simple socket server 
 * - assume transaction of simple text send and receive
 * @author Michael Druckman
 */
public class ServerConventions implements Runnable
{


	// types of request processors

	/**
	 * processor base type.
	 * actual implementer must extend this interface.
	 * implementer of just base interface will generate exception.
	 */
	public interface Processor {}

	/**
	 * processor for simple text requests
	 */
	public interface RawTextProcessor extends Processor
	{
		/**
		 * provide simple processing for text transaction
		 * @param request text request for transaction
		 * @return text response to request
		 */
		String process (String request);
	}

	/**
	 * processor for JSON requests
	 */
	public interface JsonProcessor extends Processor
	{
		/**
		 * provide simple processing for JSON transaction
		 * @param request JSON request for transaction
		 * @return text response to request
		 */
		String process (JsonSemantics.JsonValue value);
	}

	/**
	 * provide access to a SAX parser handler
	 */
	public interface SaxProcessor extends Processor
	{
		DefaultHandler getHandler ();
		String getResponse ();
	}

	/**
	 * processor for XML requests
	 */
	public interface XmlProcessor extends Processor
	{
		SaxProcessor getSaxProcessor ();
	}

	// types of request processors [end of list]


	/**
	 * @param port the port number to be provided to socket server
	 * @param processor an implementation of text transaction conventions
	 * @param terminator the text of the request that will terminate the service
	 */
	public ServerConventions (int port, Processor processor, String terminator)
	{
		server = new ServerTcpIO (port);
		this.terminator = terminator;
		this.processor = processor;
	}
	protected Processor processor;
	protected ServerTcpIO server;
	protected String terminator;


	/**
	 * execute a server instance in a parallel thread
	 * @param port the port number to be provided to socket server
	 * @param processor an implementation of text transaction conventions
	 * @param terminator the text of the request that will terminate the service
	 */
	public static void provideService
	(int port, Processor processor, String terminator)
	{
		new Thread
		(
			new ServerConventions (port, processor, terminator)
		).run ();
	}


	/* (non-Javadoc)
	 * @see java.lang.Runnable#run()
	 */
	public void run ()
	{
		process ();
	}
	

	/**
	 * infinite loop of accept on socket
	 */
	public void process ()
	{
		try 
		{
			do {
				process (server.accept ());
			} while (true);
		}
		catch (Exception e) {}
	}


	/**
	 * @param c a connection to be processed
	 */
	public void process (ServerTcpIO.Connection c)
	{
		try
		{
			String request, response;

			if ((request = c.read ()).equals (terminator))
			{
				c.write ("Termination request seen, server exit");
				throw new RuntimeException ("Termination request seen");
			}

			if (processor instanceof RawTextProcessor)
			{ response = ((RawTextProcessor) processor).process (request); }
			else if (processor instanceof XmlProcessor) response = processXml (request);
			else if (processor instanceof JsonProcessor) response = processJson (request);
			else throw new RuntimeException ("Processor not recognized");
			c.write (response);
		}
		catch (Exception e) { ServerTcpIO.error ("Processor error", e); }
		finally { c.close (); }
	}


	/**
	 * process a JSON request packet
	 * @param request the text string assumed to be JSON source
	 * @return the response generated by the JSON processor
	 * @throws Exception for JSON parser errors
	 */
	public String processJson (String request) throws Exception
	{
		TextSource source = new TextSource (readerFor (request));
		return ((JsonProcessor) processor).process (JsonReader.readFrom (source));
	}


	/**
	 * process an XML request packet
	 * @param request the text string assumed to be XML source
	 * @return the response generated by the XML processor
	 * @throws Exception for XML parser errors
	 */
	public String processXml (String request) throws Exception
	{
		SaxProcessor sax =
			((XmlProcessor) processor).getSaxProcessor ();
		parse (readerFor (request), sax);
		return sax.getResponse ();
	}

	public void parse (Reader source, SaxProcessor processor) throws Exception
	{ getSAXParser ().parse (new InputSource (source), processor.getHandler ()); }

	static final SAXParserFactory PARSER_FACTORY = SAXParserFactory.newInstance ();
	public static SAXParser getSAXParser () throws ParserConfigurationException, SAXException
	{ return PARSER_FACTORY.newSAXParser (); }


	/**
	 * provider a Reader for text source
	 * @param text string source for reader
	 * @return a Reader object
	 */
	public static Reader readerFor (String text)
	{ return new StringReader (text); }


}

